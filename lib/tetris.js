// Generated by CoffeeScript 1.4.0

/*
SUBLIME KEYS:
- alt + shift + s (syntax check)
- alt + shift + c (compile)
- alt + shift + w (watch)

TODO:
- grids collisions test
- collide and move down
- block sprites
- animation
*/


(function() {
  var Grid, b, blocks, blocks2, i, row, t, _i, _j, _len;

  Grid = (function() {

    function Grid(w, h, arr, color) {
      this.w = w;
      this.h = h;
      this._a = new Array(this.w * this.h);
      if (arr != null) {
        this.setArray(arr);
      }
      if (color != null) {
        this.color = color;
      }
    }

    Grid.prototype.get = function(x, y) {
      return this._a[this.w * y + x];
    };

    Grid.prototype.set = function(x, y, v) {
      if (v == null) {
        v = true;
      }
      return this._a[this.w * y + x] = v;
    };

    Grid.prototype.unset = function(x, y) {
      return this.set(x, y, false);
    };

    Grid.prototype.setArray = function(arr) {
      var p, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        p = arr[_i];
        _results.push(this.set(p[0], p[1]));
      }
      return _results;
    };

    Grid.prototype.rotatedClone = function() {
      var n, x, y, _i, _j, _ref, _ref1;
      n = new Grid(this.h, this.w);
      for (y = _i = 0, _ref = this.h; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = this.w; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          n.set(this.h - y - 1, x, !!this.get(x, y));
        }
      }
      if (this.color != null) {
        n.color = this.color;
      }
      return n;
    };

    Grid.prototype.r = function() {
      return this.rotatedClone();
    };

    Grid.prototype.collides = function(n, pos) {
      var x, y, _i, _j, _ref, _ref1;
      if (pos[0] < 0 || pos[1] < 0 || pos[0] + n.w > this.w || pos[1] + n.h > this.h) {
        return true;
      }
      for (y = _i = 0, _ref = n.h; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = n.w; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          if (n.get(x, y && this.get(x + pos[0], y + pos[1]))) {
            return true;
          }
        }
      }
      return false;
    };

    Grid.prototype.put = function(n, pos) {
      var hasColor, v, x, y, _i, _ref, _results;
      hasColor = n.color != null;
      _results = [];
      for (y = _i = 0, _ref = n.h; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (x = _j = 0, _ref1 = n.w; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            v = n.get(x, y);
            if (v) {
              if (hasColor) {
                v = n.color;
              }
              _results1.push(this.set(x + pos[0], y + pos[1], v));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Grid.prototype.eraseLine = function(y) {
      var x, _i, _ref, _results;
      _results = [];
      for (x = _i = 0, _ref = this.w; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        _results.push(this.unset(x, y));
      }
      return _results;
    };

    Grid.prototype.gravity = function(y) {
      var x, _i, _j, _ref;
      for (y = _i = y; y <= 1 ? _i <= 1 : _i >= 1; y = y <= 1 ? ++_i : --_i) {
        for (x = _j = 0, _ref = this.w; 0 <= _ref ? _j < _ref : _j > _ref; x = 0 <= _ref ? ++_j : --_j) {
          this.set(x, y(this.get(x, y - 1)));
        }
      }
      return this.eraseLine(0);
    };

    return Grid;

  })();

  blocks = [new Grid(4, 1, [[0, 0], [1, 0], [2, 0], [3, 0]], '#700'), new Grid(3, 2, [[0, 0], [0, 1], [1, 1], [2, 1]], '#070'), new Grid(3, 2, [[2, 0], [0, 1], [1, 1], [2, 1]], '#007'), new Grid(2, 2, [[0, 0], [1, 0], [0, 1], [1, 1]], '#770'), new Grid(3, 2, [[1, 0], [2, 0], [0, 1], [1, 1]], '#077'), new Grid(3, 2, [[1, 0], [0, 1], [1, 1], [2, 1]], '#707'), new Grid(3, 2, [[0, 0], [1, 0], [1, 1], [2, 1]], '#444')];

  blocks2 = [];

  for (_i = 0, _len = blocks.length; _i < _len; _i++) {
    b = blocks[_i];
    row = [];
    for (i = _j = 0; _j <= 3; i = ++_j) {
      row.push(b);
      b = b.r();
    }
    blocks2.push(row);
  }

  window.Tetris = {
    init: function(containerEl, cellSize) {
      this.containerEl = containerEl != null ? containerEl : document.body;
      this.cellSize = cellSize != null ? cellSize : 12;
      this.state = {
        score: 0,
        grid: new Grid(10, 16),
        piece: {
          idx: 1,
          rot: 0,
          pos: [0, 0]
        }
      };
      this._cvsEl = document.createElement('canvas');
      this._cvsW = this.state.grid.w * this.cellSize;
      this._cvsH = this.state.grid.h * this.cellSize;
      this._cvsEl.setAttribute('width', this._cvsW);
      this._cvsEl.setAttribute('height', this._cvsH);
      this.containerEl.appendChild(this._cvsEl);
      this.ctx = this._cvsEl.getContext('2d');
      this.updatePiece();
      return this.draw();
    },
    updatePiece: function() {
      var p;
      p = this.state.piece;
      return this.state.piece.grid = blocks2[p.idx][p.rot];
    },
    draw: function() {
      var p, s;
      s = this.state;
      p = s.piece;
      this.ctx.clearRect(0, 0, this._cvsW, this._cvsH);
      this.drawGrid(p.grid, this.ctx, p.pos);
    },
    drawGrid: function(g, ctx, dlt) {
      var cs, gridHasColor, v, x, y, _k, _l, _ref, _ref1;
      if (dlt == null) {
        dlt = [0, 0];
      }
      gridHasColor = g.color != null;
      if (gridHasColor) {
        ctx.fillStyle = g.color;
      }
      cs = this.cellSize;
      for (y = _k = 0, _ref = g.h; 0 <= _ref ? _k < _ref : _k > _ref; y = 0 <= _ref ? ++_k : --_k) {
        for (x = _l = 0, _ref1 = g.w; 0 <= _ref1 ? _l < _ref1 : _l > _ref1; x = 0 <= _ref1 ? ++_l : --_l) {
          v = g.get(x, y);
          if (v) {
            if (!gridHasColor) {
              ctx.fillStyle = v;
            }
            ctx.fillRect((dlt[0] + x) * cs, (dlt[1] + y) * cs, cs, cs);
          }
        }
      }
    },
    left: function() {
      var p;
      p = this.state.piece.pos;
      if (p[0] > 0) {
        p[0] -= 1;
      }
      return this.draw();
    },
    right: function() {
      var p;
      p = this.state.piece.pos;
      if (p[0] < this.state.grid.w - this.state.piece.grid.w) {
        p[0] += 1;
      }
      return this.draw();
    },
    rotR: function() {
      var p;
      p = this.state.piece;
      if (p.rot > 0) {
        p.rot -= 1;
      } else {
        p.rot = 3;
      }
      this.updatePiece();
      return this.draw();
    },
    rotL: function() {
      var p;
      p = this.state.piece;
      if (p.rot < 3) {
        p.rot += 1;
      } else {
        p.rot = 0;
      }
      this.updatePiece();
      return this.draw();
    },
    down: function() {},
    downAll: function() {}
  };

  t = window.Tetris;

  t.init();

  document.addEventListener('keydown', function(ev) {
    switch (ev.keyCode) {
      case 37:
        return t.left();
      case 39:
        return t.right();
      case 38:
      case 88:
        return t.rotR();
      case 90:
        return t.rotL();
      case 40:
        return t.down();
      case 32:
        return t.downAll();
    }
  });

}).call(this);
