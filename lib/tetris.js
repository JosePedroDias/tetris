// Generated by CoffeeScript 1.4.0

/*
SUBLIME KEYS:
- alt + shift + s (syntax check)
- alt + shift + c (compile)
- alt + shift + w (watch)

TODO:
- fix eraseLine and gravity bug
- score and increasing levels (easy)
- block sprites
- animation
*/


(function() {
  var $, Grid, b, blocks, blocks2, i, row, t, _i, _j, _len;

  $ = function(sel) {
    if (typeof sel === 'string') {
      return document.querySelector(sel);
    } else {
      return sel;
    }
  };

  Grid = (function() {

    function Grid(w, h, arr, color) {
      this.w = w;
      this.h = h;
      this._a = new Array(this.w * this.h);
      if (arr != null) {
        this.setArray(arr);
      }
      if (color != null) {
        this.color = color;
      }
    }

    Grid.prototype.get = function(x, y) {
      return this._a[this.w * y + x];
    };

    Grid.prototype.set = function(x, y, v) {
      if (v == null) {
        v = true;
      }
      return this._a[this.w * y + x] = v;
    };

    Grid.prototype.unset = function(x, y) {
      return this.set(x, y, false);
    };

    Grid.prototype.setArray = function(arr) {
      var p, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        p = arr[_i];
        _results.push(this.set(p[0], p[1]));
      }
      return _results;
    };

    Grid.prototype.rotatedClone = function() {
      var n, x, y, _i, _j, _ref, _ref1;
      n = new Grid(this.h, this.w);
      for (y = _i = 0, _ref = this.h; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = this.w; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          n.set(this.h - y - 1, x, !!this.get(x, y));
        }
      }
      if (this.color != null) {
        n.color = this.color;
      }
      return n;
    };

    Grid.prototype.r = function() {
      return this.rotatedClone();
    };

    Grid.prototype.collides = function(n, pos) {
      var x, y, _i, _j, _ref, _ref1;
      if (pos[0] < 0 || pos[1] < 0 || pos[0] + n.w > this.w || pos[1] + n.h > this.h) {
        return true;
      }
      for (y = _i = 0, _ref = n.h; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = n.w; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          if (n.get(x, y) && this.get(x + pos[0], y + pos[1])) {
            return true;
          }
        }
      }
      return false;
    };

    Grid.prototype.put = function(n, pos) {
      var hasColor, v, x, y, _i, _ref, _results;
      hasColor = n.color != null;
      _results = [];
      for (y = _i = 0, _ref = n.h; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (x = _j = 0, _ref1 = n.w; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            v = n.get(x, y);
            if (v) {
              if (hasColor) {
                v = n.color;
              }
              _results1.push(this.set(x + pos[0], y + pos[1], v));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Grid.prototype.isLineFilled = function(y) {
      var x, _i, _ref;
      for (x = _i = 0, _ref = this.w; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        if (!this.get(x, y)) {
          return false;
        }
      }
      return true;
    };

    Grid.prototype.eraseLine = function(y) {
      var x, _i, _ref;
      for (x = _i = 0, _ref = this.w; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        this.unset(x, y);
      }
      return false;
    };

    Grid.prototype.copyLineAbove = function(y) {
      var v, x, _i, _ref, _results;
      _results = [];
      for (x = _i = 0, _ref = this.w; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        v = this.get(x, y - 1);
        if (v) {
          _results.push(this.set(x, y, v));
        } else {
          _results.push(this.unset(x, y));
        }
      }
      return _results;
    };

    Grid.prototype.gravity = function(y0) {
      var y, _i;
      for (y = _i = y0; y0 <= 0 ? _i < 0 : _i > 0; y = y0 <= 0 ? ++_i : --_i) {
        this.copyLineAbove(y);
      }
      return this.eraseLine(0);
    };

    Grid.prototype.toString = function() {
      var r, x, y, _i, _j, _ref, _ref1;
      r = [];
      for (y = _i = 0, _ref = this.h; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = this.w; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          if (this.get(x, y)) {
            r.push('O');
          } else {
            r.push('.');
          }
        }
        r.push('\n');
      }
      return r.join('');
    };

    return Grid;

  })();

  blocks = [new Grid(4, 1, [[0, 0], [1, 0], [2, 0], [3, 0]], '#700'), new Grid(3, 2, [[0, 0], [0, 1], [1, 1], [2, 1]], '#070'), new Grid(3, 2, [[2, 0], [0, 1], [1, 1], [2, 1]], '#007'), new Grid(2, 2, [[0, 0], [1, 0], [0, 1], [1, 1]], '#770'), new Grid(3, 2, [[1, 0], [2, 0], [0, 1], [1, 1]], '#077'), new Grid(3, 2, [[1, 0], [0, 1], [1, 1], [2, 1]], '#707'), new Grid(3, 2, [[0, 0], [1, 0], [1, 1], [2, 1]], '#444')];

  blocks2 = [];

  for (_i = 0, _len = blocks.length; _i < _len; _i++) {
    b = blocks[_i];
    row = [];
    for (i = _j = 0; _j <= 3; i = ++_j) {
      row.push(b);
      b = b.r();
    }
    blocks2.push(row);
  }

  window.Tetris = {
    init: function(o) {
      this._containerEl = document.body;
      this._cellSize = 16;
      if (o.container != null) {
        this._containerEl = $(o.container);
      }
      if (o.cellSize != null) {
        this._cellSize = o.cellSize;
      }
      if (o.score != null) {
        this._scoreEl = $(o.score);
      }
      if (o.next != null) {
        this._nextEl = $(o.next);
      }
      this.restartGame();
      this._cvsEl = document.createElement('canvas');
      this._cvsW = this.state.grid.w * this._cellSize;
      this._cvsH = this.state.grid.h * this._cellSize;
      this._cvsEl.setAttribute('width', this._cvsW);
      this._cvsEl.setAttribute('height', this._cvsH);
      this._containerEl.appendChild(this._cvsEl);
      this._nextPieceCvsEl = document.createElement('canvas');
      this._nextPieceCvsEl.setAttribute('width', 4 * this._cellSize);
      this._nextPieceCvsEl.setAttribute('height', 4 * this._cellSize);
      this._nextEl.appendChild(this._nextPieceCvsEl);
      this._ctx = this._cvsEl.getContext('2d');
      this._nextPieceCtx = this._nextPieceCvsEl.getContext('2d');
      return this.draw();
    },
    restartGame: function() {
      this.state = {
        score: 0,
        grid: new Grid(10, 16),
        level: 0,
        piece: {
          idx: Math.floor(Math.random() * 7),
          rot: 0,
          pos: [4, 0]
        },
        nextPiece: {
          idx: Math.floor(Math.random() * 7),
          rot: 0,
          pos: [0, 0]
        }
      };
      this.updatePiece();
      this.updatePiece(true);
      this.increaseScore();
      return this.timer = setInterval(this.down.bind(this), 300);
    },
    updatePiece: function(next) {
      var p;
      p = next ? this.state.nextPiece : this.state.piece;
      /*if next
        p.pos = [
          (4 - p.grid.w) / 2,
          (4 - p.grid.h) / 2
        ]
      */

      return p.grid = blocks2[p.idx][p.rot];
    },
    increaseScore: function(nrLines) {
      var inc, s;
      if (nrLines == null) {
        nrLines = 0;
      }
      s = this.state;
      inc = (function() {
        switch (nrLines) {
          case 0:
            return 0;
          case 1:
            return 40;
          case 2:
            return 100;
          case 1:
            return 300;
          case 2:
            return 1200;
        }
      })();
      s.score += inc * (s.level + 1);
      return this.updateScore("level:" + s.level + " score:" + s.score);
    },
    updateScore: function(msg) {
      return this._scoreEl.innerHTML = msg;
    },
    draw: function() {
      var p, s;
      s = this.state;
      p = s.piece;
      this._ctx.clearRect(0, 0, this._cvsW, this._cvsH);
      this.drawGrid(s.grid, this._ctx);
      if (!this.skipPieceDraw) {
        this.drawGrid(p.grid, this._ctx, p.pos);
      }
      this._nextPieceCtx.clearRect(0, 0, this._cellSize * 4, this._cellSize * 4);
      this.drawGrid(s.nextPiece.grid, this._nextPieceCtx);
    },
    drawGrid: function(g, ctx, dlt) {
      var cs, gridHasColor, v, x, y, _k, _l, _ref, _ref1;
      if (dlt == null) {
        dlt = [0, 0];
      }
      gridHasColor = g.color != null;
      if (gridHasColor) {
        ctx.fillStyle = g.color;
      }
      cs = this._cellSize;
      for (y = _k = 0, _ref = g.h; 0 <= _ref ? _k < _ref : _k > _ref; y = 0 <= _ref ? ++_k : --_k) {
        for (x = _l = 0, _ref1 = g.w; 0 <= _ref1 ? _l < _ref1 : _l > _ref1; x = 0 <= _ref1 ? ++_l : --_l) {
          v = g.get(x, y);
          if (v) {
            if (!gridHasColor) {
              ctx.fillStyle = v;
            }
            ctx.fillRect((dlt[0] + x) * cs, (dlt[1] + y) * cs, cs, cs);
          }
        }
      }
    },
    isColliding: function() {
      return this.state.grid.collides(this.state.piece.grid, this.state.piece.pos);
    },
    endGame: function() {
      clearInterval(this.timer);
      this.updateScore('game over');
      return true;
    },
    correctCollision: function(x, y) {
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      if (!this.isColliding()) {
        return false;
      }
      if (y > 0) {
        this.state.piece.pos[1] -= 1;
        if (this.isColliding()) {
          return this.endGame();
        }
        this.gluePiece();
      } else if (x === (-1) || x === 1) {
        this.state.piece.pos[0] -= x;
      } else {
        this.state.piece.pos[0] += 1;
        if (this.isColliding()) {
          this.state.piece.pos[0] -= 2;
          if (this.isColliding()) {
            return this.endGame();
          }
        }
        return false;
      }
      return true;
    },
    gluePiece: function() {
      var dy, g, isF, np, nrLines, p, pos, y;
      g = this.state.grid;
      p = this.state.piece;
      np = this.state.nextPiece;
      pos = p.pos;
      g.put(p.grid, pos);
      nrLines = 0;
      dy = p.grid.h - 1;
      while (dy >= 0) {
        y = pos[1] + dy;
        isF = g.isLineFilled(y);
        if (isF) {
          nrLines += 1;
          g.gravity(y);
        } else {
          dy -= 1;
        }
      }
      if (nrLines > 0) {
        this.increaseScore(nrLines);
      }
      p.idx = np.idx;
      p.rot = 0;
      p.pos = [4, 0];
      np.idx = Math.floor(Math.random() * 7);
      this.updatePiece();
      this.updatePiece(true);
      return this.draw();
    },
    left: function() {
      this.state.piece.pos[0] -= 1;
      this.correctCollision(-1);
      return this.draw();
    },
    right: function() {
      this.state.piece.pos[0] += 1;
      this.correctCollision(1);
      return this.draw();
    },
    rotR: function() {
      var p;
      p = this.state.piece;
      if (p.rot > 0) {
        p.rot -= 1;
      } else {
        p.rot = 3;
      }
      this.updatePiece();
      this.correctCollision();
      return this.draw();
    },
    rotL: function() {
      var p;
      p = this.state.piece;
      if (p.rot < 3) {
        p.rot += 1;
      } else {
        p.rot = 0;
      }
      this.updatePiece();
      this.correctCollision();
      return this.draw();
    },
    down: function() {
      this.state.piece.pos[1] += 1;
      this.correctCollision(0, 1);
      return this.draw();
    },
    downAll: function() {
      var _results;
      _results = [];
      while (!this.correctCollision(0, 1)) {
        _results.push(this.state.piece.pos[1] += 1);
      }
      return _results;
    }
  };

  t = window.Tetris;

  t.init({
    container: '#grid',
    score: '#score',
    next: '#next'
  });

  document.addEventListener('keydown', function(ev) {
    switch (ev.keyCode) {
      case 37:
        return t.left();
      case 39:
        return t.right();
      case 38:
      case 88:
        return t.rotR();
      case 90:
        return t.rotL();
      case 40:
        return t.down();
      case 32:
        return t.downAll();
    }
  });

}).call(this);
