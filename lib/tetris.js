// Generated by CoffeeScript 1.4.0

/*
SUBLIME KEYS:
- alt + shift + s (syntax check)
- alt + shift + c (compile)
- alt + shift + w (watch)

TODO:
- fix eraseLine and gravity bug
- score and increasing levels (easy)
- block sprites
- animation
*/


(function() {
  var Grid, alert2, b, blocks, blocks2, i, row, t, _i, _j, _len;

  alert2 = function(msg) {
    return document.body.appendChild(document.createTextNode(msg));
  };

  Grid = (function() {

    function Grid(w, h, arr, color) {
      this.w = w;
      this.h = h;
      this._a = new Array(this.w * this.h);
      if (arr != null) {
        this.setArray(arr);
      }
      if (color != null) {
        this.color = color;
      }
    }

    Grid.prototype.get = function(x, y) {
      return this._a[this.w * y + x];
    };

    Grid.prototype.set = function(x, y, v) {
      if (v == null) {
        v = true;
      }
      return this._a[this.w * y + x] = v;
    };

    Grid.prototype.unset = function(x, y) {
      return this.set(x, y, false);
    };

    Grid.prototype.setArray = function(arr) {
      var p, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        p = arr[_i];
        _results.push(this.set(p[0], p[1]));
      }
      return _results;
    };

    Grid.prototype.rotatedClone = function() {
      var n, x, y, _i, _j, _ref, _ref1;
      n = new Grid(this.h, this.w);
      for (y = _i = 0, _ref = this.h; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = this.w; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          n.set(this.h - y - 1, x, !!this.get(x, y));
        }
      }
      if (this.color != null) {
        n.color = this.color;
      }
      return n;
    };

    Grid.prototype.r = function() {
      return this.rotatedClone();
    };

    Grid.prototype.collides = function(n, pos) {
      var x, y, _i, _j, _ref, _ref1;
      if (pos[0] < 0 || pos[1] < 0 || pos[0] + n.w > this.w || pos[1] + n.h > this.h) {
        return true;
      }
      for (y = _i = 0, _ref = n.h; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = n.w; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          if (n.get(x, y) && this.get(x + pos[0], y + pos[1])) {
            return true;
          }
        }
      }
      return false;
    };

    Grid.prototype.put = function(n, pos) {
      var hasColor, v, x, y, _i, _ref, _results;
      hasColor = n.color != null;
      _results = [];
      for (y = _i = 0, _ref = n.h; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (x = _j = 0, _ref1 = n.w; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            v = n.get(x, y);
            if (v) {
              if (hasColor) {
                v = n.color;
              }
              _results1.push(this.set(x + pos[0], y + pos[1], v));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Grid.prototype.isLineFilled = function(y) {
      var x, _i, _ref;
      for (x = _i = 0, _ref = this.w; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        if (!this.get(x, y)) {
          return false;
        }
      }
      return true;
    };

    Grid.prototype.eraseLine = function(y) {
      var x, _i, _ref;
      for (x = _i = 0, _ref = this.w; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        this.unset(x, y);
      }
      return false;
    };

    Grid.prototype.copyLineAbove = function(y) {
      var v, x, _i, _ref, _results;
      _results = [];
      for (x = _i = 0, _ref = this.w; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        v = this.get(x, y - 1);
        _results.push(this.set(x, y, v != null ? v : {
          v: false
        }));
      }
      return _results;
    };

    Grid.prototype.gravity = function(y0) {
      var y, _i;
      for (y = _i = y0; y0 <= 0 ? _i < 0 : _i > 0; y = y0 <= 0 ? ++_i : --_i) {
        this.copyLineAbove(y);
      }
      return this.eraseLine(0);
    };

    Grid.prototype.toString = function() {
      var r, x, y, _i, _j, _ref, _ref1;
      r = [];
      for (y = _i = 0, _ref = this.h; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = this.w; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          r.push(this.get(x, y != null ? y : {
            'O': '.'
          }));
        }
        r.push('\n');
      }
      return r.join('');
    };

    return Grid;

  })();

  blocks = [new Grid(4, 1, [[0, 0], [1, 0], [2, 0], [3, 0]], '#700'), new Grid(3, 2, [[0, 0], [0, 1], [1, 1], [2, 1]], '#070'), new Grid(3, 2, [[2, 0], [0, 1], [1, 1], [2, 1]], '#007'), new Grid(2, 2, [[0, 0], [1, 0], [0, 1], [1, 1]], '#770'), new Grid(3, 2, [[1, 0], [2, 0], [0, 1], [1, 1]], '#077'), new Grid(3, 2, [[1, 0], [0, 1], [1, 1], [2, 1]], '#707'), new Grid(3, 2, [[0, 0], [1, 0], [1, 1], [2, 1]], '#444')];

  blocks2 = [];

  for (_i = 0, _len = blocks.length; _i < _len; _i++) {
    b = blocks[_i];
    row = [];
    for (i = _j = 0; _j <= 3; i = ++_j) {
      row.push(b);
      b = b.r();
    }
    blocks2.push(row);
  }

  window.Tetris = {
    init: function(containerEl, cellSize) {
      this.containerEl = containerEl != null ? containerEl : document.body;
      this.cellSize = cellSize != null ? cellSize : 12;
      this.restartGame();
      this._cvsEl = document.createElement('canvas');
      this._cvsW = this.state.grid.w * this.cellSize;
      this._cvsH = this.state.grid.h * this.cellSize;
      this._cvsEl.setAttribute('width', this._cvsW);
      this._cvsEl.setAttribute('height', this._cvsH);
      this.containerEl.appendChild(this._cvsEl);
      this.ctx = this._cvsEl.getContext('2d');
      return this.draw();
    },
    restartGame: function() {
      this.state = {
        score: 0,
        grid: new Grid(10, 16),
        piece: {
          idx: Math.floor(Math.random() * 7),
          rot: 0,
          pos: [4, 0]
        }
      };
      this.updatePiece();
      return this.timer = setInterval(this.down.bind(this), 250);
    },
    updatePiece: function() {
      var p;
      p = this.state.piece;
      return this.state.piece.grid = blocks2[p.idx][p.rot];
    },
    draw: function() {
      var p, s;
      s = this.state;
      p = s.piece;
      this.ctx.clearRect(0, 0, this._cvsW, this._cvsH);
      this.drawGrid(s.grid, this.ctx);
      this.drawGrid(p.grid, this.ctx, p.pos);
    },
    drawGrid: function(g, ctx, dlt) {
      var cs, gridHasColor, v, x, y, _k, _l, _ref, _ref1;
      if (dlt == null) {
        dlt = [0, 0];
      }
      gridHasColor = g.color != null;
      if (gridHasColor) {
        ctx.fillStyle = g.color;
      }
      cs = this.cellSize;
      for (y = _k = 0, _ref = g.h; 0 <= _ref ? _k < _ref : _k > _ref; y = 0 <= _ref ? ++_k : --_k) {
        for (x = _l = 0, _ref1 = g.w; 0 <= _ref1 ? _l < _ref1 : _l > _ref1; x = 0 <= _ref1 ? ++_l : --_l) {
          v = g.get(x, y);
          if (v) {
            if (!gridHasColor) {
              ctx.fillStyle = v;
            }
            ctx.fillRect((dlt[0] + x) * cs, (dlt[1] + y) * cs, cs, cs);
          }
        }
      }
    },
    isColliding: function() {
      return this.state.grid.collides(this.state.piece.grid, this.state.piece.pos);
    },
    endGame: function() {
      clearInterval(this.timer);
      alert2('game over');
      return true;
    },
    correctCollision: function(x, y) {
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      if (!this.isColliding()) {
        return false;
      }
      if (y > 0) {
        this.state.piece.pos[1] -= 1;
        if (this.isColliding()) {
          return this.endGame();
        }
        this.gluePiece();
      } else if (x === (-1) || x === 1) {
        this.state.piece.pos[0] -= x;
      } else {
        this.state.piece.pos[0] += 1;
        if (this.isColliding()) {
          this.state.piece.pos[0] -= 2;
          if (this.isColliding()) {
            return this.endGame();
          }
        }
        return false;
      }
      return true;
    },
    gluePiece: function() {
      var g, p, pos, y, _k, _ref, _ref1;
      g = this.state.grid;
      p = this.state.piece;
      pos = p.pos;
      g.put(p.grid, pos);
      for (y = _k = _ref = pos[1] + p.grid.h, _ref1 = pos[1]; _ref <= _ref1 ? _k < _ref1 : _k > _ref1; y = _ref <= _ref1 ? ++_k : --_k) {
        if (g.isLineFilled(y)) {
          g.gravity(y);
          y -= 1;
        }
      }
      p.idx = Math.floor(Math.random() * 7);
      p.rot = 0;
      p.pos = [4, 0];
      this.updatePiece();
      return this.draw();
    },
    left: function() {
      this.state.piece.pos[0] -= 1;
      this.correctCollision(-1);
      return this.draw();
    },
    right: function() {
      this.state.piece.pos[0] += 1;
      this.correctCollision(1);
      return this.draw();
    },
    rotR: function() {
      var p;
      p = this.state.piece;
      if (p.rot > 0) {
        p.rot -= 1;
      } else {
        p.rot = 3;
      }
      this.updatePiece();
      this.correctCollision();
      return this.draw();
    },
    rotL: function() {
      var p;
      p = this.state.piece;
      if (p.rot < 3) {
        p.rot += 1;
      } else {
        p.rot = 0;
      }
      this.updatePiece();
      this.correctCollision();
      return this.draw();
    },
    down: function() {
      this.state.piece.pos[1] += 1;
      this.correctCollision(0, 1);
      return this.draw();
    },
    downAll: function() {
      var _results;
      _results = [];
      while (!this.correctCollision(0, 1)) {
        _results.push(this.state.piece.pos[1] += 1);
      }
      return _results;
    }
  };

  t = window.Tetris;

  t.init();

  document.addEventListener('keydown', function(ev) {
    switch (ev.keyCode) {
      case 37:
        return t.left();
      case 39:
        return t.right();
      case 38:
      case 88:
        return t.rotR();
      case 90:
        return t.rotL();
      case 40:
        return t.down();
      case 32:
        return t.downAll();
    }
  });

}).call(this);
